<pre>
  BIP: XYZ
  Title: Extended Transaction
  Author: Noel Tiernan <tier.nolan@gmail.com>
  Status: Draft
  Type: Standards Track
  Created: 2015-05-10
</pre>

==Abstract==

Transactions reference all unspent transaction outputs (UTXOs) by transaction id (txid) and index.  No other information about the UTXO is contained in the transaction which spends it.

This BIP describes a transaction serialization wth sufficient infomation about the UTXOs being spent to fully verify the transaction, other than UTXO existence and double spend checks.  This is purely a network protocol change.  The transaction serialization used for signing and generating the txid is not modified.

==Motivation==

The are primarily two benefits from this change.

# Each UTXOs entry in the database can be reduced in size
# Improves transactions verification locality

====UTXO Entry Size====

The UTXO database stores key/value pairs.  Every transaction that has at least one unspent output is contained in the database.

The key used is the txid (32 bytes) and the value is a compressed representation of the UTXOs for that transaction.

For each UTXO, four pieces of information are stored; the value of the UTXO, the scriptPubKey, the height it was included in the chain and if the transaction was a coinbase transaction.

At the time of writing, the UTXO set serialization is 35.89 bytes per UTXO.  

If all the information about the UTXO was known, then the UTXOs could be stored in the database as a set of hashes.  Each entry could be stored as the first bytes of hash(txid | index | height | is_coinbase | scriptPubKey | value).

If the first 8 bytes were stored and assuming 20 million UTXOs in the set, the odds of a collision is 1 in 92234.  With 10 bytes, the odds are one in 6 billion.  Collisions are unlikely to occur in practice, so blocks that cause collisions could simply be rejected.  One of the colliding transactions could be included in the block and the other transaction(s) could be included in later block.  This would change the height value and the transaction would be unlikely to collide.

The odds of a node accepting a false transaction is even lower.  If 8 bytes is used per entry, a transaction with a non-existent input has a one in 922 billion chance of being accepted.  Even knowing the node_specific_salt, this is considerable effort and only one node will actually accept the false transaction.

In addition, since the UTXO entry size can be fixed, it may be possible to store the database more efficiently due to fixed field sizes.  Very long scriptPubKeys can be supported without increasing the UTXO database size.

====Transaction Verification Locality====

If the scriptPubKey, value and coinbase status for all UTXOs spent by a transaction are known, transactions can be nearly completely verified without any additional information.  The only checks that can't be done locally are checking for double spending and making sure the outputs spent actually exist.

This could help with the new consensus ibrary.  The block verification function could be given a block header and a list of extended transactions and it could verify them locally.  The function could give a list of the digests of all UTXOs consumed, and a list of the digests of all new digests created.  A client using the library only has to manage the UTXO digest set.  Everything else can be handled by the consensus library.

==Specification==

This BIP defines a change to how transactions are encoded.  This affects the transaction, "tx", and block, "block" messages.  The new serialization format is used if the protocol version number is 70003 or greater.

The format change only applies to the p2p protocol.  Transactions are still serialized as before when signing and determining the txid.

====Transaction Message====

The new transaction, "tx", message is identical, except for additional fields in the OutPoint datatype.  The new OutPoint field is defined as follows.

{|class="wikitable"
! Field Size !! Description !! Data type !! Comments
|-
| 32 || txid || uint256 || The txid of the referenced transaction
|-
| 4 || index || uint32_t || The index of the UTXO
|-
| 8 || value || int64_t || The value of the UTXO (New)
|-
| 1 || utxo_type || uchar || The type of the UTXO (New)
|-
| 1+ || pk_script_length || var_int || Length of the pk_script (New)
|-
| ? || pk_script || uchar[] || The public key script for the output (New)
|-
| 4 || height || uint32_t || The minimum block height that this UTXO can be included in (New)
|}

The minimum height is equal to the height of the block that the transaction is included in, or height + COINBASE_MATURITY for coinbase UTXOs.

There are three UTXO types.

{|class="wikitable"
! Value !! Name !! Description
|-
| 0 || UTXO_RAW || Uncompressed pk_script
|-
| 1 || UTXO_P2SH || Pay to script hash template
|-
| 2 || UTXO_P2PKH || Pay to public key hash template
|}

The pk_script array is only used for the UTXO_RAW type.  In the other two cases, it stores a zero length array and the pk_script is recovered from the signature script.  

Use of the UTXO_P2SH and UTXO_P2PKH type is mandatory, if the UTXO matches the template.

====Block Message====

The new block, "block", message is identical to the block message, except transaction are serialized as using the new format.

====Service Flag====

Upgraded nodes should assert the EXTENDED_TX service bit.  This means that the node supports the new transaction format.

====PK Script Recovery====

The pk_script can be recovered from the signature script when the pay to script hash and pay to public key hash templates are used.

The signature script is run to determine the top entry in the stack.  If the stack is empty or the top entry is not 20 bytes, then the transaction is invalid.

The template for P2SH is as follows.

{|class="wikitable"
! Byte Index !! Byte Value !! Opcode Name ||  Notes
|-
| 0 || 0xA9 || OP_HASH160 || 
|-
| 1 || 0x14 || Push 20 bytes || 
|-
| 2-21 || Script Hash || || Copy the top of the stack
|-
| 22 || 0x87 || OP_EQUAL || 
|}

The template for P2PKH is as follows.

{|class="wikitable"
! Byte Index !! Byte Value !! Opcode Name ||  Notes
|-
| 0 || 0x76 || OP_DUP || 
|-
| 1 || 0xA9 || OP_HASH160 || 
|-
| 2 || 0x14 || Push 20 bytes || 
|-
| 3-22 || Key Hash || || Copy the top of the stack
|-
| 23 || 0x88 || OP_EQUALVERIFY ||
|-
| 24 || 0xAC || OP_CHECKSIG ||
|}

==Special Case Rule For BIP30 Compliance==

There are two pairs of coinbase transactions that have the same txid.  Only one output of each pair is spendable, but all 4 outputs would generate different digests.

This would mean that all 4 are spendable, which is incorrect and could cause a fork.

An additional rule is required to prevent all 4 outputs being added into the UTXO set.  This can be achieved by excluding the 2nd coinbase of each pair from being included in the UTXO set.  The condition is the same as for BIP30.

    
    bool fExcludeCoinbaseUTXO = !((pindex->nHeight==91842 && pindex->GetBlockHash() == uint256("0x00000000000a4d0a398161ffc163c503763b1f4360639393e0e4c8e300e0caec")) ||
                                  (pindex->nHeight==91880 && pindex->GetBlockHash() == uint256("0x00000000000743f190a18c5577a3c2d2a1f610ae9601ac046a38084ccb7cd721")));
    
    
When processing those two blocks, the UTXO from the coinbase must not be added to the UTXO set.

==Canonical Digest==

The canonical digest for each UTXO shall be equal to first 10 bytes of the digest given when the UTXO serialization is passed to the double SHA256 hash function.

The UTXO set serialization is as follows.

{|class="wikitable"
! Field Size !! Description !! Data type !! Comments
|-
| 32 || txid || uint256 || The txid of the referenced transaction
|-
| 4 || index || uint32_t || The index of the UTXO
|-
| 8 || value || int64_t || The value of the UTXO
|-
| ? || pk_script || uchar[] || The public key script for the output
|-
| 4 || height || uint32_t || The minimum block height that this UTXO can be included in
|}

==Soft Fork Rule==

Transactions with outputs which collide with entries in the UTXO set may not be included in the block.  The block is processed from the first transaction to the last.  UTXOs spent by the transaction are removed from the set before its outputs are added.

Two UTXOs collide if they both have the same canonical digest.

Since the height field is incremented for each block.  In the unlikely event of a collision, the colliding unconfirmed transaction can simply be included in the next block.

==Deployment==

The PROTOCOL_VERSION is incremented from 70002 to 70003.

Transactions and blocks received from legacy nodes must be converted to new format before forwarding to new upgraded peers.

Transactions should not be forwarded, except as part of a block, if any of the signature scripts contains non-push opcodes.

The soft fork mechanism in effect at the time of deployment shall be used to handle the no-collision rule for the canonical digests.

==Backward Compatibility==

The two new message formats can be converted into the old format by dropping the additional information.  This allows updated nodes to easily communicate with legacy nodes.

There will be three types of nodes.

* Legacy nodes
* Full Border nodes
* UTXO-lite nodes

Legacy nodes are nodes which haven't upgraded to the extended transaction format.  

Full border nodes are upgraded nodes which maintain the full UTXO set.  They can upgrade the transaction and block messages to the new format and send information to legacy nodes.  They act as border nodes between legacy and UTXO-lite nodes, allowing information from legacy nodes to reach UTXO-lite nodes.

UTXO-lite nodes are nodes which only store the reduced UTXO digest set.  This type of node would not exist initially.  When deployed, they would only make outgoing connections to EXTENDED_TX nodes.  As long as they receive extended blocks, they are fully verifying nodes.

If all miners run upgraded nodes, then all new blocks would initially be broadcast in extended format and legacy nodes could receive downgraded versions.

Legacy nodes may be unable to spend their coins unless they peer with nodes that can perform the upgrade, directly or via a path of legacy nodes.  Wallet software could easily be updated to produce etx messages.  It is more efficient for wallets to manage their own UTXOs than expecting the data to be stored on every noce.  This creates an incentive for wallet users to upgrade.  
